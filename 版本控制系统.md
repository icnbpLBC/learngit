# 版本控制系统

* 版本控制是一种记录一个或若干文件内容变化【只能跟踪文本文件的改动，二进制文件无法跟踪】，以便将来查阅特定版本修订情况的系统。 

## 分布式版本控制系统

* 分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。
* 如 Git
  * 独有的分支管理
  * 工作区：git管理的目录
  * 版本库：工作区有一个隐藏目录`.git`，Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的**暂存区**，还有Git为我们自动创建的第一个分支`master`，以及指向`master`的一个指针叫`HEAD`。
  * Git**跟踪并管理的是修改**，而非文件

## 集中式的版本控制系统

* 如SVN、CVS

* SVN创建和切换分支比蜗牛还慢

* 版本库是集中存放在中央服务器的

## 区别

* 集中式就是所有代码库都只保存在一个中心服务器并且为核心代码库，C端全部是其的离线拷贝，所有提交最终都要汇总到中心服务器，并且可以影响全部离线拷贝。
* 分布式是所有代码都可以随意从一个P端分发到不同的P端上，并且各自平行并互不干扰，本地提交只影响本地代码库，只有推送到指定的中心服务器（意义上的，和SVN的实质性的不同），并且其他P端更新下来后才会影响其他P端。中心服务器也只是其中一个P端，不具实质性（可以任意指定）。
* https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6







初始化一个Git仓库，使用`git init`命令。

添加文件到Git仓库，分两步：

1. 使用命令`git add <file>`，注意，可反复多次使用，添加多个文件；把文件**修改添加**到**暂存区**；
2. 使用命令`git commit -m <message>`，完成。保存一个快照。把**暂存区的所有内容提交到当前分支**。



- 要随时掌握工作区的状态，使用`git status`命令。
- 如果`git status`告诉你有文件被修改过，用`git diff`可以查看修改内容。版本库里面最新版本和查看工作区的区别
  - 读懂diffhttp://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html



* HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。【回退版本库中记录的某个版本】
* 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。
* 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。



* 查看分支：`git branch`

  创建分支：`git branch <name>`

  切换分支：`git checkout <name>`或者`git switch <name>`

  创建+切换分支：`git checkout -b <name>`或者`git switch -c <name>`

  合并某分支到当前分支：`git merge <name>`

  删除分支：`git branch -d <name>`

* 一、分支之间的跳转，一般是提交后切换，即git diff HEAD 无差异；，**因为不同分支共用工作区和暂存区**，如果切换的其他分支修改工作区未commit时，再切换到其他分支都能看到对应工作区和暂存区的修改。

  二、分支跳转完成后后，工作区目录会恢复到当前分支最近一次提交下的目录情况，即不同分支底下的目录内容即便存在差异，也不会互相干扰泾渭分明。

* 分支就是指针！

  每次commit 都是把新的 东西 提交（带着一个id）

  而分支，就是指向这些commit的指针。

  而HEAD，则是指向当前分支的指针。



* 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改【增删改】时，用命令`git restore file`。【丢弃工作区的修改】

  * 一种是`readme.txt`自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；【用版本库里的版本替换工作区的版本】

    一种是`readme.txt`已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。

* 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令`git restore --staged file`，就回到了场景1，第二步按场景1操作。【丢弃暂存区的修改】

* 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考[版本回退](https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192)一节，不过前提是没有推送到远程库。



* **命令`git rm`用于手动删除一个文件加上git add**。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失**最近一次提交后你修改的内容**。



* 本地Git仓库和GitHub仓库【一般为公开】之间的传输是通过SSH非对称加密的，为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的【验证流程：服务端公钥加密信息回传客户端，客户端接收信息私钥解密再回发，服务端验证是否通过】，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。![image-20221211134313781](../../img/image-20221211134313781.png)

* 要关联一个远程库，使用命令`git remote add origin git@server-name:path/repo-name.git`；

  关联一个远程库时必须给远程库**指定一个名字**，`origin`是默认习惯命名；

  关联后，使用命令`git push -u origin master`第一次推送master分支的所有内容；

  此后，每次本地提交后，只要有必要，就可以使用命令`git push origin master`推送最新修改；

  解除了本地和远程的绑定关系：`git remote -v` 查看远程库信息，`git remote rm origin`根据名字解绑。

  分布式版本系统的最大好处之一是**在本地工作完全不需要考虑远程库的存在**，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！



* 要克隆一个仓库，首先必须知道仓库的地址，然后使用`git clone`命令克隆。

  Git支持多种协议，默认的`git://`使用ssh，使用`https`除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用`ssh`协议而只能用`https`。



* 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。

  解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。

  用`git log --graph`命令可以看到分支合并图。

* Git分支十分强大，在团队开发中应该充分应用。

  合并分支时，加上`--no-ff`参数就可以用普通模式合并，**合并后的历史有分支**【**本次合并要创建一个新的commit**】，能看出来曾经做过合并，而`fast forward`合并就看不出来曾经做过合并。【f f模式合并如新增会丢失分支信息】



* 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；

  当手头工作没有完成时，先把工作现场`git stash`一下，然后去修复bug，修复后，再`git stash pop`，回到工作现场；

  在master分支上修复的bug，想要合并到当前dev分支，可以用`git cherry-pick <commit>`命令，把bug提交的修改“复制”到当前分支，避免重复劳动。



* 开发一个新feature，最好新建一个分支；
* 如果要丢弃一个没有被合并过的分支，可以通过`git branch -D <name>`强行删除。



* 查看远程库信息，使用`git remote -v`；
* 本地新建的分支如果不推送到远程，对其他人就是不可见的；
* 从本地推送分支，使用`git push origin branch-name`，如果推送失败，先用`git pull`抓取远程的新提交；
* 在本地创建和远程分支对应的分支，使用`git checkout -b branch-name origin/branch-name`，本地和远程分支的名称最好一致；
* 建立本地分支和远程分支的关联，使用`git branch --set-upstream branch-name origin/branch-name`；
* 从远程抓取分支，使用`git pull`，如果有冲突，要先处理冲突。